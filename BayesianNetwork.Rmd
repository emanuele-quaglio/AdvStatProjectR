---
title: "R Notebook"
output: html_notebook
---

```{r}
#install.packages("tidyverse")
library(tidyverse)
#install.packages("conflicted")
#install.packages("ggraph")
library(igraph)
library(ggraph)
library(conflicted)
#install.packages("foreach")
#install.packages("doParallel")
library(foreach)
library(doParallel)



```

```{r}
print_grouped_df <- function(grouped_df) {
  # Loop over each group
  groups <- group_split(grouped_df)
  group_vars <- group_vars(grouped_df)
  
  for (i in seq_along(groups)) {
    # Get the current group data
    current_group <- groups[[i]]
    
    # Extract the values of the grouping variables for this group
    group_keys <- current_group[1, group_vars, drop = FALSE]
    
    # Print the group header with key values
    cat("\n==== Group:", paste(names(group_keys), "=", as.character(group_keys), collapse = ", "), "====\n")
    
    # Print the current group
    print(current_group)
  }
}


options(paged.print = FALSE)
# Algorithm
k2_algorithm <- function(data, nodes, max_parents = 10) {
  
  
  
  # Initialize the network
  network <- setNames(vector("list", length(nodes)), nodes)
  network[] <- lapply(network, function(x) character(0))
  #E' PROBABILE CHE CI VOGLIA QUALCOSA DI PIU'SPECIFICO DI UNA LIST, ES. net.dag <- empty.graph(nodes=nodes) 
  
  Prod_j<-function(df, i, parents, r){
    return(prod(df %>%
              group_by_at(parents) %>%
              summarise(N_ij = n()) %>% 
              mutate(ratio = factorial(r[i] - 1) / factorial(N_ij + r[i] - 1))))
  }
  
  Prod_jk<-function(df, i, parents){
    return(prod(df %>%
              group_by_at(c(parents, i)) %>%
              summarise(count = n()) %>%
              mutate(factorial_count = factorial(count))))
  }

  f_20<-function(original_df, i, parents, r){
    prod_g_ij=Prod_j(original_df, i, parents, r)
    prod_f_ijk=Prod_jk(original_df, i, parents)
    return (prod_g_ij*prod_f_ijk)
  }

  
  # Detect the number of available cores
  numCores <- parallel::detectCores()
  
  # Create a cluster with the desired number of cores
  cl <- makeCluster(numCores - 1)  # Use one less core than available
  
  # Register the cluster for parallel processing
  registerDoParallel(cl)
  # Parallel execution example
  result <- foreach(i = 1:5, .combine = c) %dopar% {
    i^2  # Square of i
  }
  print(result)
  stopCluster(cl)
  
  # Iterate over each node
  result<-foreach (i = 2:length(nodes), .combine = 'c') %dopar% {
    cat('NODO: ', i, '\n')
     # Calculate r_i:
    r<-map_int(data, n_distinct)
  
    parents <- c()
    score_old <- Prod_jk(data, i, parents)
    proceed <- TRUE
    while (proceed && length(parents) < max_parents) {
      cat('PARENTS: ', parents, '\n')

      # Find the best candidate parent
      best_parent <- NULL
      best_score <- score_old

      for (z in setdiff(nodes[1:(i-1)], parents)) {
        best_score <- f_20(data, i, parents, r)
        cat(best_score, score_old)
        if (best_score > score_old) { 
          best_parent <- z
          score_old <- best_score
        }
      }

      # Update parents and score if necessary
      if (!is.null(best_parent) & best_score > score_old) {
        parents <- c(parents, best_parent)
        score_old <- best_score
      } else {
        proceed <- FALSE
      }
    }
    
    # Return the parents for the current node
    return(list(node = nodes[i], parents = if(length(parents) == 0) character(0) else sapply(parents, function(el) nodes[el])))

  }
  
  # Assign results to the network
  for (res in result) {
    network[[res$node]] <- res$parents
  }
  
  return(network)
}

```

```{r}
print_network<-function(network){
  edges <- tibble(
      from = unlist(network),
      to = rep(names(network), sapply(network, length))
    )
  # Creazione del grafo
  graph <- graph_from_data_frame(edges, directed = TRUE)
  # Visualizzazione del grafo
  ggraph(graph, layout = "tree") +
    #coord_cartesian(xlim = c(-0.6, 0.6), ylim = c(-0.2, 1.1)) +
    geom_node_point(shape = 21, size = 20, color = "green") +
    geom_node_text(aes(label = name), repel = FALSE, fontface = "bold", nudge_x = +0, nudge_y = +0) +
    geom_edge_link(arrow = arrow(length = unit(0.2, "inches"), type = "closed"),
                   end_cap = circle(), start_cap = circle()) +
    theme_graph() +
    labs(title = "Rete Bayesiana")
}



```


```{r}
trial_df <- data.frame(
  x1 = c(1, 1, 0, 1, 0, 0, 0, 0, 1, 0),
  x2 = c(0, 1, 1, 1, 0, 1, 1, 0, 1, 0),
  x3 = c(0, 1, 1, 1, 0, 1, 1, 0, 1, 0)
)



network<-k2_algorithm(trial_df, c("x1", "x2", "x3"), 2)
print(network)
print_network(network)
```

